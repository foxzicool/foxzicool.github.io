<!doctype html>
<html lang="zh-Hant">
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆæœ¬åœ°å³æ™‚åŸéŸ³ï¼‹ä¼ºæœå™¨è­¯éŸ³ï½œæ¸¬è©¦å›è½ç‰ˆï¼‰</title>
<style>
  body{font-family:system-ui,-apple-system,"Noto Sans TC","Microsoft JhengHei",Arial;padding:20px;max-width:980px;margin:auto}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input,select,button{padding:8px 10px;border:1px solid #bbb;border-radius:10px;background:#fff}
  button{cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .pill{padding:4px 10px;border-radius:999px;background:#efefef;font-size:12px}
  .logs{margin-top:12px;padding:10px;border:1px solid #eee;border-radius:10px;background:#fafafa;height:360px;overflow:auto;font-size:14px;white-space:pre-wrap}
  .now{color:#1b7fbd}
  .stat{font-family:monospace}
  .hint{color:#666;font-size:13px}
  .meter{width:160px;height:10px;background:#eee;border-radius:6px;overflow:hidden;position:relative}
  .bar{height:100%;width:0%;background:#1b7fbd;transition:width .08s linear}
  .gate{padding:2px 6px;border-radius:6px;background:#ddd}
  .gate.open{background:#16a34a;color:#fff}
  .gate.closed{background:#ef4444;color:#fff}
</style>
<body>
  <h2>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆæœ¬åœ°å³æ™‚åŸéŸ³ï¼‹ä¼ºæœå™¨è­¯éŸ³ï½œæ¸¬è©¦å›è½ç‰ˆï¼‰</h2>

  <div class="row">
    <label>åç¨±</label>
    <input id="name" type="text" placeholder="ä½ çš„åå­—" value="Public"/>
    <label>ä¾†æºèªè¨€</label>
    <select id="srcLang">
      <option value="zh" selected>ä¸­æ–‡</option>
      <option value="ko">éŸ“æ–‡</option>
    </select>
    <button id="join">åŠ å…¥</button>
    <button id="leave" disabled>é›¢é–‹</button>
    <span class="pill" id="status">æœªé€£ç·š</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label><input id="mute" type="checkbox"> ä¸é€å‡ºéº¥å…‹é¢¨</label>
    <label><input id="echo" type="checkbox" checked> å›è²æŠ‘åˆ¶</label>
    <label><input id="ns"   type="checkbox" checked> é™å™ª</label>
    <label><input id="agc"  type="checkbox" checked> è‡ªå‹•å¢ç›Š</label>
    <label><input id="forceGate" type="checkbox"> å¼·åˆ¶é–‹é–˜</label>
    <span class="stat" id="tx">TX: 0 pkt/s</span>
    <span class="stat" id="rmsTxt">RMS: 0.000</span>
    <span class="gate closed" id="gateSta">GATE</span>
    <div class="meter"><div class="bar" id="rmsBar"></div></div>
  </div>

  <div class="row" style="margin-top:10px">
    <label for="micSel">éº¥å…‹é¢¨</label>
    <select id="micSel"></select>
    <label for="outSel">è¼¸å‡ºè£ç½®</label>
    <select id="outSel"></select>
    <span class="hint">AirPodsï¼šè¼¸å…¥æŒ‘ã€ŒHeadsetã€ï¼›è¼¸å‡ºæŒ‘ã€ŒHeadphones / è€³æ©Ÿã€ã€‚</span>
  </div>

  <div class="logs" id="logs"></div>

<script>
const TUNNEL_HOST = "https://easier-downtown-essex-president.trycloudflare.com";

let ws=null, audioCtx=null, workletNode=null, spNode=null, stream=null, pingTimer=null, txTimer=null;
let playQueue=[], playing=false, joined=false, txPkts=0;
let micSource=null, loopbackEl=null;
let nullSink=null; // æŠŠè™•ç†ç¯€é»ä¸²åˆ° 0 å¢ç›Šï¼Œç¢ºä¿è¢«ã€Œæ‹‰å‹•ã€

let devicesCache=[];
let currentMicId = "";
let currentOutId = "";

// Gate/æ¿¾æ³¢åƒæ•¸ï¼ˆé™é–€æª»ï¼Œè¼ƒå®¹æ˜“é–‹é–€ï¼‰
const GATE_OPEN_RMS  = 0.003;
const GATE_CLOSE_RMS = 0.002;
const GATE_HANG_FR   = 3;
const HP_FREQ = 120;
const LP_FREQ = 8000;

const $  = (s)=>document.querySelector(s);
const log= (s)=>{ const el=$('#logs'); el.textContent+=s+"\n"; el.scrollTop=el.scrollHeight; };

function setGateUI(open, rms){
  $('#rmsTxt').textContent = `RMS: ${rms.toFixed(3)}`;
  $('#rmsBar').style.width = `${Math.min(100, rms*4000)}%`;
  const el = $('#gateSta');
  el.textContent = open ? 'GATE é–‹' : 'GATE é—œ';
  el.classList.toggle('open',   open);
  el.classList.toggle('closed', !open);
}

async function refreshDevices(){
  devicesCache = await navigator.mediaDevices.enumerateDevices();
  const mics = devicesCache.filter(d=>d.kind==="audioinput");
  const outs = devicesCache.filter(d=>d.kind==="audiooutput");

  const micSel=$('#micSel'); micSel.innerHTML="";
  mics.forEach(d=>{
    const o=document.createElement('option');
    o.value=d.deviceId;
    o.textContent = d.label || `éº¥å…‹é¢¨(${d.deviceId.slice(0,6)}â€¦)`;
    micSel.appendChild(o);
  });

  const outSel=$('#outSel'); outSel.innerHTML="";
  outs.forEach(d=>{
    const o=document.createElement('option');
    o.value=d.deviceId;
    o.textContent = d.label || `è¼¸å‡º(${d.deviceId.slice(0,6)}â€¦)`;
    outSel.appendChild(o);
  });

  if (currentMicId && [...micSel.options].some(o=>o.value===currentMicId)) micSel.value=currentMicId;
  if (currentOutId && [...outSel.options].some(o=>o.value===currentOutId)) outSel.value=currentOutId;
}

function pickOutputForMic(micId){
  const mic = devicesCache.find(d=>d.deviceId===micId && d.kind==="audioinput");
  const outs = devicesCache.filter(d=>d.kind==="audiooutput");
  if (!mic || outs.length===0) return;
  let cand = outs.filter(o=>o.groupId && mic.groupId && o.groupId===mic.groupId);
  const prefer = (label)=>/headphone|headset|airpods|buds|è€³æ©Ÿ|è—ç‰™/i.test(label||"");
  cand = cand.sort((a,b)=> (prefer(b.label)?1:0) - (prefer(a.label)?1:0));
  const pick = cand[0] || outs[0];
  currentOutId = pick.deviceId;
  $('#outSel').value = currentOutId;
}

async function getMicStream(deviceId){
  const cts = {
    audio:{
      deviceId: deviceId ? {exact: deviceId} : undefined,
      channelCount:{ideal:1},
      sampleRate:  {ideal:48000},
      sampleSize:  {ideal:16},
      echoCancellation: {ideal: $('#echo').checked},
      noiseSuppression: {ideal: $('#ns').checked},
      voiceIsolation:   {ideal: true},
      autoGainControl:  $('#agc').checked ? {ideal:true} : {ideal:false}
    }
  };
  return await navigator.mediaDevices.getUserMedia(cts);
}

function stopStream(s){ try{ s && s.getTracks().forEach(t=>t.stop()); }catch(_){} }

async function buildAudioPipeline(deviceId){
  // æ¸…èˆŠ
  try{ workletNode && workletNode.disconnect(); }catch(_){}
  try{ spNode && spNode.disconnect(); }catch(_){}
  try{ nullSink && nullSink.disconnect(); }catch(_){}
  stopStream(stream);
  try{ audioCtx && await audioCtx.close(); }catch(_){}

  audioCtx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000});
  await audioCtx.resume().catch(()=>{});

  // 0 å¢ç›ŠåŒ¯æµæ’ï¼Œç¢ºä¿ä¸Šå‚³ç¯€é»è¢«ã€Œæ‹‰å‹•ã€
  nullSink = audioCtx.createGain();
  nullSink.gain.value = 0;
  nullSink.connect(audioCtx.destination);

  stream = await getMicStream(deviceId);
  const info = stream.getAudioTracks()[0]?.getSettings?.() || {};
  currentMicId = deviceId || "";
  log(`ğŸ™ï¸ micï¼š${(stream.getAudioTracks()[0]?.label)||'æœªçŸ¥'} | è¨­å®šï¼š${JSON.stringify(info)}`);

  if (!currentOutId) { await refreshDevices(); pickOutputForMic($('#micSel').value || currentMicId); }

  micSource = audioCtx.createMediaStreamSource(stream);

  // æœ¬åœ°ç›£è½ï¼ˆé«˜é€š+ä½é€š+å£“ç¸®ï¼‰â†’ MediaStreamDestination â†’ <audio> loopback
  try{
    const hp = audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value = HP_FREQ;
    const lp = audioCtx.createBiquadFilter(); lp.type='lowpass';  lp.frequency.value = LP_FREQ;
    const comp = audioCtx.createDynamicsCompressor();
    comp.threshold.value = -40; comp.knee.value = 5; comp.ratio.value = 6; comp.attack.value = 0.01; comp.release.value = 0.25;

    const dest = audioCtx.createMediaStreamDestination();
    micSource.connect(hp); hp.connect(lp); lp.connect(comp); comp.connect(dest);

    if (loopbackEl){ try{ loopbackEl.pause(); }catch(_){ } }
    loopbackEl = new Audio();
    loopbackEl.autoplay = true;
    loopbackEl.srcObject = dest.stream;
    if (typeof loopbackEl.setSinkId === 'function' && currentOutId) {
      try { await loopbackEl.setSinkId(currentOutId); } catch(e){ log(`âš ï¸ è¿´æ”¾è¼¸å‡ºè¨­å®šå¤±æ•—ï¼š${e}`); }
    }
    // å…ˆéœéŸ³ï¼Œç­‰ gate é–‹æ‰æ‰“é–‹
    loopbackEl.muted = true;
    await loopbackEl.play().catch(()=>{});
  }catch(e){
    log(`âš ï¸ æœ¬åœ°è™•ç†/ç›£è½å»ºç«‹å¤±æ•—ï¼š${e}`);
    try{
      if (loopbackEl){ try{ loopbackEl.pause(); }catch(_){ } }
      loopbackEl = new Audio();
      loopbackEl.autoplay = true;
      loopbackEl.srcObject = stream;
      if (typeof loopbackEl.setSinkId === 'function' && currentOutId) {
        try { await loopbackEl.setSinkId(currentOutId); } catch(e){ log(`âš ï¸ è¿´æ”¾è¼¸å‡ºè¨­å®šå¤±æ•—ï¼š${e}`); }
      }
      loopbackEl.muted = false;
      await loopbackEl.play().catch(()=>{});
    }catch(_){}
  }

  // ä¸Šå‚³ç¯€é»ï¼š48k -> 16kï¼Œä¸¦åš gate
  try{
    let lastRmsUpdate = 0;

    const postFrame = (int16buf)=>{
      // RMS
      let ss=0; for(let n=0;n<int16buf.length;n++){ const v=int16buf[n]/32768; ss+=v*v; }
      const rms = Math.sqrt(ss/int16buf.length);

      // Gate
      let open = gateState.open;
      if ($('#forceGate').checked) {
        open = true;
      } else {
        if (!open && rms >= GATE_OPEN_RMS) { open = true; gateState.hang = GATE_HANG_FR; }
        if (open  && rms <  GATE_CLOSE_RMS) { gateState.hang = Math.max(0, gateState.hang-1); if (gateState.hang===0) open=false; }
      }
      gateState.open = open;

      // UI 200ms æ›´æ–°ä¸€æ¬¡
      const t = performance.now();
      if (t - lastRmsUpdate > 200) {
        setGateUI(open, rms);
        lastRmsUpdate = t;
      }

      // æœ¬åœ°ç›£è½åªåœ¨èªªè©±æ™‚æ‰“é–‹
      if (loopbackEl) { loopbackEl.muted = !open; }

      if (open) {
        txPkts++;
        if(!$('#mute').checked && ws && ws.readyState===1){
          ws.send(int16buf.buffer);
        }
      }
    };

    const gateState = {open:false, hang:0};

    if (audioCtx.audioWorklet) {
      const blobURL = URL.createObjectURL(new Blob([`
        class ResampleWorklet extends AudioWorkletProcessor {
          constructor(){ super(); this.srcRate=sampleRate; this.dstRate=16000; }
          process(inputs){
            const i=inputs[0]; if(!i||!i[0]) return true;
            const x=i[0]; const ratio=this.srcRate/this.dstRate;
            const outLen=Math.floor(x.length/ratio);
            const pcm=new Int16Array(outLen);
            for(let k=0;k<outLen;k++){
              const pos=k*ratio; const i0=Math.floor(pos); const i1=Math.min(i0+1, x.length-1);
              const t=pos-i0; let s = x[i0]*(1-t) + x[i1]*t;
              s=Math.max(-1,Math.min(1,s)); pcm[k]=s<0?s*0x8000:s*0x7FFF;
            }
            for(let off=0; off<pcm.length; off+=320){
              const sl=pcm.subarray(off, off+320);
              if(sl.length===320) this.port.postMessage(sl.buffer,[sl.buffer]);
            }
            return true;
          }
        }
        registerProcessor('resample-worklet', ResampleWorklet);
      `], {type:'application/javascript'}));
      await audioCtx.audioWorklet.addModule(blobURL);
      workletNode = new AudioWorkletNode(audioCtx, 'resample-worklet');
      // ç¢ºä¿ç¯€é»è¢«æ‹‰å‹•
      workletNode.connect(nullSink);

      workletNode.port.onmessage = (e)=>{ postFrame(new Int16Array(e.data)); };
      micSource.connect(workletNode);
      spNode=null;
      log(`âœ… Worklet å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
    } else {
      spNode = audioCtx.createScriptProcessor(2048,1,1);
      spNode.onaudioprocess = (ev)=>{
        const ch=ev.inputBuffer.getChannelData(0);
        const ratio=48000/16000;
        const outLen=Math.floor(ch.length/ratio);
        const pcm=new Int16Array(outLen);
        for(let k=0;k<outLen;k++){
          const pos=k*ratio; const i0=Math.floor(pos); const i1=Math.min(i0+1, ch.length-1);
          const t=pos-i0; let s = ch[i0]*(1-t) + ch[i1]*t;
          s=Math.max(-1,Math.min(1,s)); pcm[k]=s<0?s*0x8000:s*0x7FFF;
        }
        for(let off=0; off<pcm.length; off+=320){
          const sl=pcm.subarray(off, off+320);
          if(sl.length===320){ postFrame(sl); }
        }
      };
      micSource.connect(spNode);
      // ç¢ºä¿ç¯€é»è¢«æ‹‰å‹•
      spNode.connect(nullSink);
      workletNode=null;
      log(`âœ… ScriptProcessor å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
    }
  }catch(e){ log(`âš ï¸ ä¸Šå‚³ç¯€é»éŒ¯èª¤ï¼š${e}`); }
}

function cleanupAll(){
  try{ workletNode && workletNode.disconnect(); }catch(_){}
  try{ spNode && spNode.disconnect(); }catch(_){}
  try{ nullSink && nullSink.disconnect(); }catch(_){}
  stopStream(stream);
  try{ audioCtx && audioCtx.close(); }catch(_){}
  try{ clearInterval(pingTimer); }catch(_){}
  try{ clearInterval(txTimer); }catch(_){}
  workletNode=spNode=micSource=null; nullSink=null; audioCtx=stream=null; pingTimer=txTimer=null; txPkts=0;
  if (loopbackEl){ try{ loopbackEl.pause(); }catch(_){ } loopbackEl=null; }
  setGateUI(false, 0);
  $('#tx').textContent = 'TX: 0 pkt/s';
}

function leave(){
  if(ws){ try{ ws.close(); }catch(_){} }
  cleanupAll();
  $('#join').disabled=false; $('#leave').disabled=true; joined=false;
  $('#status').textContent="æœªé€£ç·š"; $('#status').classList.remove('now');
}

async function join(){
  if (joined) return;
  try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){}
  await refreshDevices();

  const airMic = devicesCache.find(d=>d.kind==="audioinput"  && /airpods|headset/i.test(d.label||""));
  const airOut = devicesCache.find(d=>d.kind==="audiooutput" && /airpods|headphone/i.test(d.label||""));
  if (airMic) { currentMicId = airMic.deviceId; $('#micSel').value=currentMicId; }
  if (airOut) { currentOutId = airOut.deviceId; $('#outSel').value=currentOutId; }

  const name = ($('#name').value || 'Guest').trim().slice(0,40);
  const srcLang = $('#srcLang').value;

  ws = new WebSocket(`${TUNNEL_HOST.replace('https://','wss://')}/ws`);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async ()=>{
    $('#status').textContent="å·²é€£ç·š"; $('#status').classList.add('now');
    ws.send(JSON.stringify({name, src_lang: srcLang}));

    await buildAudioPipeline($('#micSel').value || undefined);

    txTimer = setInterval(()=>{ $('#tx').textContent = `TX: ${txPkts} pkt/s`; txPkts=0; }, 1000);
    joined = true; $('#join').disabled=true; $('#leave').disabled=false;
    pingTimer = setInterval(()=>{ try{ ws.send(JSON.stringify({type:"ping"})); }catch(_){ } }, 20000);
  };

  ws.onmessage = (ev)=>{
    if(ev.data instanceof ArrayBuffer){
      // æ”¶åˆ°ä¼ºæœå™¨å»£æ’­çš„åŸéŸ³/è­¯éŸ³
      playQueue.push(ev.data);
      if(!playing) playNext();
      return;
    }
    try{
      const o=JSON.parse(ev.data);
      if(o.type==="join")    log(`ğŸ”µ ${o.name} åŠ å…¥ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="leave")   log(`âšª ${o.name} é›¢é–‹ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="final")   log(`âœ… ${o.from}ï¼ˆ${o.dir}ï¼‰\nåŸæ–‡ï¼š${o.text}\nç¿»è­¯ï¼š${o.mt}`);
      if(o.type==="mute")    log(`ğŸ”‡ ${o.name} ${o.muted?"å·²éœéŸ³":"å–æ¶ˆéœéŸ³"}`);
      if(o.type==="error")   log(`âŒ ${o.msg}`);
    }catch(_){}
  };

  ws.onclose = ()=>{ log("é€£ç·šé—œé–‰"); leave(); };
}

function sniffMime(buf){
  if (buf.byteLength >= 12){
    const dv = new DataView(buf);
    const riff = String.fromCharCode(dv.getUint8(0),dv.getUint8(1),dv.getUint8(2),dv.getUint8(3));
    const wave = String.fromCharCode(dv.getUint8(8),dv.getUint8(9),dv.getUint8(10),dv.getUint8(11));
    if (riff === 'RIFF' && wave === 'WAVE') return 'audio/wav';
  }
  return 'audio/mpeg';
}

async function playNext(){
  if(playQueue.length===0){ playing=false; return; }
  playing=true;
  const buf=playQueue.shift();
  const mime = sniffMime(buf);
  const blob=new Blob([buf],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=new Audio(url);
  a.autoplay = true;
  if (typeof a.setSinkId === 'function' && currentOutId) {
    try { await a.setSinkId(currentOutId); } catch(e){ log(`âš ï¸ è¨­å®šæ’­æ”¾è¼¸å‡ºå¤±æ•—ï¼š${e}`); }
  }
  a.onended=()=>{ URL.revokeObjectURL(url); playNext(); };
  a.play().catch(()=>{ /* éœ€è¦ä½¿ç”¨è€…äº’å‹•æ‰å¯è‡ªå‹•æ’­æ”¾æ™‚å¿½ç•¥ */ });
}

$('#join').onclick = join;
$('#leave').onclick = leave;
// æœ¬åœ°é˜»æ“‹ä¸Šå‚³ï¼Œä¸å¿…é€šçŸ¥ä¼ºæœå™¨
$('#mute').onchange = ()=>{};
$('#micSel').onchange = async ()=>{
  currentMicId = $('#micSel').value || "";
  await refreshDevices();
  pickOutputForMic(currentMicId);
  await buildAudioPipeline(currentMicId);
};
$('#outSel').onchange = async ()=>{
  currentOutId = $('#outSel').value || "";
  if (loopbackEl && typeof loopbackEl.setSinkId==='function' && currentOutId){
    try{ await loopbackEl.setSinkId(currentOutId); }catch(e){ log(`âš ï¸ è¿´æ”¾è¼¸å‡ºåˆ‡æ›å¤±æ•—ï¼š${e}`); }
  }
};

navigator.mediaDevices.addEventListener('devicechange', async ()=>{
  const prevMic = currentMicId, prevOut = currentOutId;
  await refreshDevices();
  if (prevMic && !devicesCache.some(d=>d.kind==="audioinput" && d.deviceId===prevMic)) {
    currentMicId = $('#micSel').value;
    await buildAudioPipeline(currentMicId);
  }
  if (prevOut && !devicesCache.some(d=>d.kind==="audiooutput" && d.deviceId===prevOut)) {
    pickOutputForMic(currentMicId || $('#micSel').value);
  }
});

// å…ˆæ‹¿æ¬Šé™å†åˆ—è£ç½®
(async ()=>{ try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){ } await refreshDevices(); })();
</script>
</body>
</html>
