<!doctype html>
<html lang="zh-Hant">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆå®Œæ•´å¥ï½œå¯å›é€åŸéŸ³æ¸¬è©¦ï¼‹æŒ‡å®šè¼¸å…¥/è¼¸å‡ºè£ç½®ï¼‰</title>
<style>
  body{font-family:system-ui,-apple-system,"Noto Sans TC","Microsoft JhengHei",Arial;padding:20px;max-width:980px;margin:auto}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input,select,button{padding:8px 10px;border:1px solid #bbb;border-radius:10px;background:#fff}
  button{cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .pill{padding:4px 10px;border-radius:999px;background:#efefef;font-size:12px}
  .logs{margin-top:12px;padding:10px;border:1px solid #eee;border-radius:10px;background:#fafafa;height:380px;overflow:auto;font-size:14px;white-space:pre-wrap}
  .now{color:#1b7fbd}
  .stat{font-family:monospace}
  .hint{color:#666;font-size:13px}
  label.inline{display:inline-flex;align-items:center;gap:6px}
</style>
<body>
  <h2>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆå®Œæ•´å¥ï¼‰</h2>

  <div class="row">
    <label>åç¨±</label>
    <input id="name" type="text" placeholder="ä½ çš„åå­—" value="Public" />
    <label>ä¾†æºèªè¨€</label>
    <select id="srcLang">
      <option value="zh" selected>ä¸­æ–‡</option>
      <option value="ko">éŸ“æ–‡</option>
    </select>
    <button id="join">åŠ å…¥</button>
    <button id="leave" disabled>é›¢é–‹</button>
    <span class="pill" id="status">æœªé€£ç·š</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label class="inline"><input id="mute" type="checkbox"> ä¸é€å‡ºéº¥å…‹é¢¨</label>
    <label class="inline"><input id="echo" type="checkbox" checked> å›è²æŠ‘åˆ¶</label>
    <label class="inline"><input id="ns"   type="checkbox" checked> é™å™ª</label>
    <label class="inline"><input id="agc"  type="checkbox" checked> è‡ªå‹•å¢ç›Š</label>
    <label class="inline"><input id="loopbackRaw" type="checkbox" checked> å›å‚³æˆ‘çš„åŸéŸ³çµ¦æˆ‘ï¼ˆæ¸¬è©¦ï¼‰</label>
    <span class="stat" id="tx">TX: 0 pkt/s</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label for="micSel">éº¥å…‹é¢¨</label>
    <select id="micSel"></select>
    <label class="inline">
      <input id="monitor" type="checkbox" checked> æœ¬åœ°å›è½è‡ªå·±ï¼ˆé›¶å»¶é²ï¼‰
    </label>
    <label class="inline">éŸ³é‡
      <input id="monVol" type="range" min="0" max="1" step="0.01" value="0.9">
    </label>
  </div>

  <div class="row" style="margin-top:10px">
    <label for="outSel">å–‡å­/è€³æ©Ÿè¼¸å‡º</label>
    <select id="outSel"></select>
    <span class="hint">å¦‚ä½¿ç”¨ AirPodsï¼šå…ˆé€£ä¸Š AirPods â†’ ä¸‹æ‹‰é¸å–®é¸å®ƒåšç‚ºè¼¸å…¥èˆ‡è¼¸å‡ºã€‚</span>
  </div>

  <div class="logs" id="logs"></div>

<script>
const TUNNEL_HOST = "https://twenty-chose-src-keeps.trycloudflare.com";

let ws=null, audioCtx=null, workletNode=null, spNode=null, stream=null, pingTimer=null, txTimer=null;
let playQueue=[], playing=false, joined=false, txPkts=0;

let monitorGain=null, monitorDest=null, monitorEl=null, micSource=null;
let currentOutId = ""; // æŒ‡å®šæ’­æ”¾è¼¸å‡ºè£ç½®ï¼ˆå«æœ¬åœ°ç›£è½èˆ‡TTSæ’­æ”¾ï¼‰

const $  = (s)=>document.querySelector(s);
const log= (s)=>{ const el=$('#logs'); el.textContent+=s+"\n"; el.scrollTop=el.scrollHeight; };

async function listDevices(){
  try{
    const devs = await navigator.mediaDevices.enumerateDevices();
    const mics = devs.filter(d=>d.kind==="audioinput");
    const outs = devs.filter(d=>d.kind==="audiooutput");

    const micSel = $('#micSel'); micSel.innerHTML="";
    mics.forEach(d=>{
      const opt=document.createElement('option');
      opt.value=d.deviceId; opt.textContent=d.label || `éº¥å…‹é¢¨ (${d.deviceId.slice(0,6)}â€¦)`;
      micSel.appendChild(opt);
    });

    const outSel = $('#outSel'); outSel.innerHTML="";
    outs.forEach(d=>{
      const opt=document.createElement('option');
      opt.value=d.deviceId; opt.textContent=d.label || `è¼¸å‡º (${d.deviceId.slice(0,6)}â€¦)`;
      outSel.appendChild(opt);
    });

    // ä¿æŒæ—¢é¸è¼¸å‡º
    if (currentOutId) {
      const found = outs.some(d=>d.deviceId===currentOutId);
      if (found) outSel.value = currentOutId;
      else currentOutId = outSel.value || "";
    } else {
      currentOutId = outSel.value || "";
    }
  }catch(e){ log(`âŒ è£ç½®åˆ—èˆ‰å¤±æ•—ï¼š${e}`); }
}

async function getMicStream(deviceId){
  const cts = {
    audio:{
      deviceId: deviceId ? {exact: deviceId} : undefined,
      channelCount:1, sampleRate:48000, sampleSize:16,
      echoCancellation: $('#echo').checked,
      noiseSuppression: $('#ns').checked,
      autoGainControl:  $('#agc').checked
    }
  };
  return await navigator.mediaDevices.getUserMedia(cts);
}

function stopStreamTracks(s){
  try{ s && s.getTracks().forEach(t=>t.stop()); }catch(_){}
}

async function setupLocalMonitorChain(){
  // ç›£è½ï¼šmonitorGain -> monitorDest(stream) -> HTMLAudioElement (setSinkId)
  monitorGain = audioCtx.createGain();
  monitorGain.gain.value = $('#monitor').checked ? Number($('#monVol').value) : 0.0;

  monitorDest = audioCtx.createMediaStreamDestination();
  monitorEl = new Audio();
  monitorEl.autoplay = true;
  monitorEl.srcObject = monitorDest.stream;

  // æŒ‡å®šè¼¸å‡ºè£ç½®ï¼ˆå¦‚ AirPodsï¼‰
  if (typeof monitorEl.setSinkId === 'function' && currentOutId) {
    try { await monitorEl.setSinkId(currentOutId); }
    catch(e){ log(`âš ï¸ è¨­å®šç›£è½è¼¸å‡ºå¤±æ•—ï¼š${e}`); }
  } else {
    // è‹¥ç€è¦½å™¨ä¸æ”¯æ´ setSinkIdï¼Œæœƒèµ°é è¨­è¼¸å‡º
  }

  // æ¥ä¸Šæœ¬åœ°ç›£è½
  micSource.connect(monitorGain).connect(monitorDest);
}

async function buildAudioPipeline(deviceId){
  // æ¸…æ‰èˆŠéˆè·¯ï¼Œä½†ä¸å‹• WS
  try{ workletNode && workletNode.disconnect(); }catch(_){}
  try{ spNode && spNode.disconnect(); }catch(_){}
  try{ monitorGain && monitorGain.disconnect(); }catch(_){}
  stopStreamTracks(stream);
  try{ audioCtx && await audioCtx.close(); }catch(_){}

  audioCtx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000});
  await audioCtx.resume().catch(()=>{});

  stream = await getMicStream(deviceId);
  const info = stream.getAudioTracks()[0]?.getSettings?.() || {};
  log(`ğŸ™ï¸ ä½¿ç”¨ä¸­éº¥å…‹é¢¨ï¼š${(stream.getAudioTracks()[0]?.label)||'æœªçŸ¥'} | è¨­å®šï¼š${JSON.stringify(info)}`);

  micSource = audioCtx.createMediaStreamSource(stream);

  // æœ¬åœ°ç›£è½ï¼ˆé›¶å»¶é²ï¼‰
  await setupLocalMonitorChain();

  // ä¸Šè¡Œï¼š48k -> 16kï¼Œ20ms å°åŒ…
  try{
    if (audioCtx.audioWorklet) {
      const blobURL = URL.createObjectURL(new Blob([`
        class PCMWorklet extends AudioWorkletProcessor {
          constructor(){ super(); this.srcRate=sampleRate; this.dstRate=16000; }
          process(inputs){
            const input=inputs[0]; if(!input||!input[0]) return true;
            const ch=input[0], ratio=this.srcRate/this.dstRate;
            const outLen=Math.floor(ch.length/ratio);
            const pcm=new Int16Array(outLen);
            for(let i=0;i<outLen;i++){
              const idx=Math.floor(i*ratio); let s=ch[idx];
              s=Math.max(-1,Math.min(1,s)); pcm[i]=s<0?s*0x8000:s*0x7FFF;
            }
            const pkt=320; // 20ms@16k
            for(let off=0; off<pcm.length; off+=pkt){
              const sl=pcm.subarray(off, off+pkt);
              if(sl.length===pkt) this.port.postMessage(sl.buffer,[sl.buffer]);
            }
            return true;
          }
        }
        registerProcessor('pcm-worklet', PCMWorklet);
      `], {type:'application/javascript'}));
      await audioCtx.audioWorklet.addModule(blobURL);
      workletNode = new AudioWorkletNode(audioCtx, 'pcm-worklet');
      workletNode.port.onmessage = (e)=>{
        txPkts++;
        if(!$('#mute').checked && ws && ws.readyState===1){
          ws.send(e.data);
        }
      };
      micSource.connect(workletNode);
      log(`âœ… Worklet å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
      spNode = null;
    } else {
      // Fallbackï¼šScriptProcessor
      spNode = audioCtx.createScriptProcessor(2048, 1, 1);
      spNode.onaudioprocess = (ev)=>{
        const ch = ev.inputBuffer.getChannelData(0);
        const ratio = 3; // 48k -> 16k
        const outLen = Math.floor(ch.length/ratio);
        const pcm = new Int16Array(outLen);
        for(let i=0;i<outLen;i++){
          let s = ch[i*ratio];
          s=Math.max(-1,Math.min(1,s)); pcm[i] = s<0 ? s*0x8000 : s*0x7FFF;
        }
        const pkt=320;
        for(let off=0; off<pcm.length; off+=pkt){
          const sl=pcm.subarray(off, off+pkt);
          if(sl.length===pkt){
            txPkts++;
            if(!$('#mute').checked && ws && ws.readyState===1){
              ws.send(sl.buffer);
            }
          }
        }
      };
      micSource.connect(spNode);
      workletNode = null;
      log(`âœ… ScriptProcessor å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
    }
  }catch(e){
    log(`âš ï¸ ä¸Šè¡Œç·¨ç¢¼ç¯€é»éŒ¯èª¤ï¼š${e}`);
  }
}

function cleanupAll(){
  try{ workletNode && workletNode.disconnect(); }catch(_){}
  try{ spNode && spNode.disconnect(); }catch(_){}
  try{ monitorGain && monitorGain.disconnect(); }catch(_){}
  stopStreamTracks(stream);
  try{ audioCtx && audioCtx.close(); }catch(_){}
  try{ clearInterval(pingTimer); }catch(_){}
  try{ clearInterval(txTimer); }catch(_){}
  workletNode=null; spNode=null; monitorGain=null; monitorDest=null; monitorEl=null; micSource=null;
  audioCtx=null; stream=null; pingTimer=null; txTimer=null; txPkts=0;
}

function leave(){
  if(ws){ try{ ws.close(); }catch(_){} }
  cleanupAll();
  $('#join').disabled=false; $('#leave').disabled=true; joined=false;
  $('#status').textContent="æœªé€£ç·š"; $('#status').classList.remove('now');
}

async function join(){
  if (joined) return;

  // å…ˆå–ä¸€æ¬¡æ¬Šé™ï¼Œä¹‹å¾Œ enumerateDevices æ‰æœƒæœ‰æ¨™ç±¤
  try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){}
  await listDevices();

  const name = ($('#name').value || 'Guest').trim().slice(0,40);
  const srcLang = $('#srcLang').value;

  ws = new WebSocket(`${TUNNEL_HOST.replace('https://','wss://')}/ws`);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async ()=>{
    $('#status').textContent="å·²é€£ç·š"; $('#status').classList.add('now');
    ws.send(JSON.stringify({name, src_lang: srcLang}));

    // é€å‡ºç•¶å‰ loopbackRaw è¨­å®šï¼ˆæ¸¬è©¦ç”¨ï¼‰
    ws.send(JSON.stringify({type:"loopback", raw: $('#loopbackRaw').checked}));

    // å»ºç«‹éŸ³è¨Šéˆè·¯ï¼ˆä½¿ç”¨ç•¶å‰é¸æ“‡çš„ micï¼‰
    await buildAudioPipeline($('#micSel').value || undefined);

    txTimer = setInterval(()=>{ $('#tx').textContent = `TX: ${txPkts} pkt/s`; txPkts=0; }, 1000);
    joined = true; $('#join').disabled=true; $('#leave').disabled=false;
    pingTimer = setInterval(()=>{ try{ ws.send(JSON.stringify({type:"ping"})); }catch(_){ } }, 20000);
  };

  ws.onmessage = (ev)=>{
    if(ev.data instanceof ArrayBuffer){
      // å¾Œç«¯ï¼šåŸéŸ³(WAV)æ˜¯å¦å›çµ¦è‡ªå·± â†’ ç”±å‹¾é¸ã€Œå›å‚³æˆ‘çš„åŸéŸ³çµ¦æˆ‘ï¼ˆæ¸¬è©¦ï¼‰ã€æ±ºå®š
      playQueue.push(ev.data);
      if(!playing) playNext();
      return;
    }
    try{
      const o=JSON.parse(ev.data);
      if(o.type==="join")    log(`ğŸ”µ ${o.name} åŠ å…¥ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="leave")   log(`âšª ${o.name} é›¢é–‹ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="final")   log(`âœ… ${o.from}ï¼ˆ${o.dir}ï¼‰\nåŸæ–‡ï¼š${o.text}\nç¿»è­¯ï¼š${o.mt}`);
      if(o.type==="mute")    log(`ğŸ”‡ ${o.name} ${o.muted?"å·²éœéŸ³":"å–æ¶ˆéœéŸ³"}`);
      if(o.type==="loopback")log(`ğŸ” å›å‚³åŸéŸ³çµ¦è‡ªå·±ï¼š${o.raw?"é–‹":"é—œ"}`);
      if(o.type==="error")   log(`âŒ ${o.msg}`);
    }catch(_){}
  };

  ws.onclose = ()=>{ log("é€£ç·šé—œé–‰"); leave(); };
}

function sniffMime(buf){
  if (buf.byteLength >= 12){
    const dv = new DataView(buf);
    const riff = String.fromCharCode(dv.getUint8(0),dv.getUint8(1),dv.getUint8(2),dv.getUint8(3));
    const wave = String.fromCharCode(dv.getUint8(8),dv.getUint8(9),dv.getUint8(10),dv.getUint8(11));
    if (riff === 'RIFF' && wave === 'WAVE') return 'audio/wav';
  }
  return 'audio/mpeg'; // TTS
}

async function playNext(){
  if(playQueue.length===0){ playing=false; return; }
  playing=true;
  const buf=playQueue.shift();
  const mime = sniffMime(buf);
  const blob=new Blob([buf],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=new Audio(url);
  a.autoplay = true;

  // æŒ‡å®šæ’­æ”¾è¼¸å‡ºï¼ˆå«TTS/åˆ¥äººçš„åŸéŸ³ï¼‰
  if (typeof a.setSinkId === 'function' && currentOutId) {
    try { await a.setSinkId(currentOutId); } catch(e){ log(`âš ï¸ è¨­å®šæ’­æ”¾è¼¸å‡ºå¤±æ•—ï¼š${e}`); }
  }

  a.onended=()=>{ URL.revokeObjectURL(url); playNext(); };
  a.play().catch(()=>{ /* æŸäº›ç€è¦½å™¨éœ€è¦äº’å‹•æ‰è‡ªå‹•æ’­æ”¾ */ });
}

$('#join').onclick = join;
$('#leave').onclick = leave;
$('#mute').onchange = ()=>{ /* åªåœ¨æœ¬åœ°é˜»æ“‹ä¸Šå‚³ï¼ŒWS ä¸å¿…é€šçŸ¥ */ };

$('#monitor').onchange = ()=>{ if(monitorGain){ monitorGain.gain.value = $('#monitor').checked ? Number($('#monVol').value) : 0.0; } };
$('#monVol').oninput   = ()=>{ if(monitorGain){ monitorGain.gain.value = $('#monitor').checked ? Number($('#monVol').value) : 0.0; } };

$('#loopbackRaw').onchange = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'loopback', raw:$('#loopbackRaw').checked})); };

$('#micSel').onchange = async ()=>{
  if(!joined) return;
  await buildAudioPipeline($('#micSel').value || undefined);
};

$('#outSel').onchange = async ()=>{
  currentOutId = $('#outSel').value || "";
  // æ›´æ–°æœ¬åœ°ç›£è½è¼¸å‡ºè£ç½®
  if(monitorEl && typeof monitorEl.setSinkId === 'function' && currentOutId){
    try{ await monitorEl.setSinkId(currentOutId); }catch(e){ log(`âš ï¸ ç›£è½è¼¸å‡ºåˆ‡æ›å¤±æ•—ï¼š${e}`); }
  }
};

navigator.mediaDevices.addEventListener('devicechange', async ()=>{
  // è£ç½®æ’æ‹”æ™‚åˆ·æ–°æ¸…å–®ï¼Œä¿ç•™æ—¢é¸ï¼›è‹¥è£ç½®æ¶ˆå¤±ï¼Œé€€å›é è¨­
  const prevMic = $('#micSel').value;
  const prevOut = $('#outSel').value;
  await listDevices();
  if (joined) {
    // è‹¥éº¥å…‹é¢¨è¢«æ‹”æ‰ï¼Œé‡å»ºä½¿ç”¨ç›®å‰ä¸‹æ‹‰é¸å–®å€¼
    if ($('#micSel').value !== prevMic) {
      await buildAudioPipeline($('#micSel').value || undefined);
    }
    // è¼¸å‡ºè£ç½®åˆ‡æ›ï¼ˆè‹¥è®Šå‹•ï¼‰
    if ($('#outSel').value !== prevOut) {
      currentOutId = $('#outSel').value || "";
      if(monitorEl && typeof monitorEl.setSinkId === 'function' && currentOutId){
        try{ await monitorEl.setSinkId(currentOutId); }catch(e){ log(`âš ï¸ ç›£è½è¼¸å‡ºåˆ‡æ›å¤±æ•—ï¼š${e}`); }
      }
    }
  }
});

// åˆæ¬¡è¼‰å…¥åˆ—èˆ‰è£ç½®
(async ()=>{ try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){}; await listDevices(); })();
</script>
</body>
</html>
