<!doctype html>
<html lang="zh-Hant">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆå–®æˆ¿ï¼‰ï½œå®Œæ•´å¥ï¼‹åŸéŸ³ç›´é€š</title>
<style>
  body{font-family:system-ui,-apple-system,"Noto Sans TC","Microsoft JhengHei",Arial;padding:20px;max-width:900px;margin:auto}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input[type=text]{padding:8px 10px;border:1px solid #ccc;border-radius:10px;min-width:220px}
  button{padding:8px 14px;border-radius:10px;border:1px solid #bbb;background:#fff;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .pill{padding:4px 10px;border-radius:999px;background:#efefef;font-size:12px}
  .logs{margin-top:12px;padding:10px;border:1px solid #eee;border-radius:10px;background:#fafafa;height:360px;overflow:auto;font-size:14px;white-space:pre-wrap}
  .now{color:#1b7fbd}
  .stat{font-family:monospace}
  label.kor{color:#666;margin-left:2px}
</style>
<body>
  <h2>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆå–®ä¸€æˆ¿é–“ï¼‰</h2>

  <div class="row">
    <label>åç¨±<span class="kor">ï¼ˆì´ë¦„ï¼‰</span></label>
    <input id="name" type="text" placeholder="ä½ çš„åå­—" value="Public">
    <button id="join">åŠ å…¥</button>
    <button id="leave" disabled>é›¢é–‹</button>
    <span class="pill" id="status">æœªé€£ç·š</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label><input id="mute" type="checkbox"> å°è‡ªå·±ç¦éŸ³</label>
    <label><input id="playSelf" type="checkbox" checked> æ’­æ”¾è‡ªå·±çš„è­¯éŸ³</label>
    <label><input id="playTTS" type="checkbox" checked> æ’­æ”¾ç¿»è­¯èªéŸ³<span class="kor">ï¼ˆë²ˆì—­ ìŒì„±ï¼‰</span></label>
    <label><input id="wantRaw" type="checkbox"> åŸéŸ³ç›´é€šï¼ˆè½å°æ–¹åŸéŸ³ï¼‰<span class="kor">ï¼ˆì›ìŒï¼‰</span></label>
    <span class="stat" id="tx">TX: 0 pkt/s</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label for="micSel">è¼¸å…¥è£ç½®<span class="kor">ï¼ˆì…ë ¥ ì¥ì¹˜ï¼‰</span></label>
    <select id="micSel"></select>
  </div>

  <div class="logs" id="logs"></div>

<script>
/* æŠŠé€™è£¡æ›æˆä½ çš„ Cloudflare Tunnel ç¶²åŸŸï¼ˆå« https://ï¼‰ */
const TUNNEL_HOST = "https://manuals-currently-cleanup-socket.trycloudflare.com";

let ws=null, audioCtx=null, worklet=null, stream=null, txTimer=null, pingTimer=null;
let joined=false, txCount=0;

const $  = (s)=>document.querySelector(s);
const log= (s)=>{ const el=$('#logs'); el.textContent+=s+"\n"; el.scrollTop=el.scrollHeight; };

async function listMics(){
  try{
    const devs = await navigator.mediaDevices.enumerateDevices();
    const mics = devs.filter(d=>d.kind==="audioinput");
    const sel = $('#micSel'); sel.innerHTML="";
    mics.forEach(d=>{
      const opt=document.createElement('option');
      opt.value=d.deviceId; opt.textContent=d.label || `éº¥å…‹é¢¨ (${d.deviceId.slice(0,6)}â€¦)`;
      sel.appendChild(opt);
    });
    if(!sel.value && mics[0]) sel.value = mics[0].deviceId;
  }catch(e){
    log(`âŒ åˆ—å‡ºè£ç½®å¤±æ•—ï¼š${e}`);
  }
}

async function getMicStream(deviceId){
  const cts = {
    audio:{
      deviceId: deviceId ? {exact: deviceId} : undefined,
      channelCount:1, sampleRate:48000, sampleSize:16,
      echoCancellation:true, noiseSuppression:true, autoGainControl:true
    }
  };
  return await navigator.mediaDevices.getUserMedia(cts);
}

async function join(){
  if (joined) return;
  await listMics();

  const name = $('#name').value.trim() || 'Guest';
  ws = new WebSocket(`${TUNNEL_HOST.replace('https://','wss://')}/ws`);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async ()=>{
    $('#status').textContent="å·²é€£ç·š"; $('#status').classList.add('now');

    // åå¥½å…ˆå‘Šè¨´å¾Œç«¯
    ws.send(JSON.stringify({
      name,
      play_self: $('#playSelf').checked,
      play_tts : $('#playTTS').checked,
      want_raw : $('#wantRaw').checked
    }));

    // å–å¾—éº¥å…‹é¢¨
    try{
      const devId = $('#micSel').value || undefined;
      stream = await getMicStream(devId);
      const track = stream.getAudioTracks()[0];
      log(`ğŸ™ï¸ mic è¼¸å…¥è£ç½®ï¼š${(track?.label)||'æœªçŸ¥'} | è¨­å®šï¼š${JSON.stringify(track?.getSettings()||{})}`);
    }catch(e){
      log(`âŒ å–å¾—éº¥å…‹é¢¨å¤±æ•—ï¼š${e}`);
      return;
    }

    // éŸ³è¨Šç®¡ç·šï¼ˆå„ªå…ˆ AudioWorkletï¼Œå¤±æ•—å‰‡ ScriptProcessorï¼‰
    audioCtx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000});

    let workletSent = 0;
    try{
      const blobURL = URL.createObjectURL(new Blob([`
        class PCMWorklet extends AudioWorkletProcessor {
          constructor(){ super(); this.srcRate=sampleRate; this.dstRate=16000; }
          process(inputs){
            const input=inputs[0]; if(!input||!input[0]) return true;
            const ch=input[0], ratio=this.srcRate/this.dstRate;
            const outLen=Math.floor(ch.length/ratio);
            const pcm=new Int16Array(outLen);
            for(let i=0;i<outLen;i++){
              const idx=Math.floor(i*ratio); let s=ch[idx];
              s=Math.max(-1,Math.min(1,s)); pcm[i]=s<0?s*0x8000:s*0x7FFF;
            }
            const pkt=320;
            for(let off=0; off<pcm.length; off+=pkt){
              const sl=pcm.subarray(off, off+pkt);
              if(sl.length===pkt) this.port.postMessage(sl.buffer,[sl.buffer]);
            }
            return true;
          }
        }
        registerProcessor('pcm-worklet', PCMWorklet);
      `], {type:'application/javascript'}));
      await audioCtx.audioWorklet.addModule(blobURL);
      const source = audioCtx.createMediaStreamSource(stream);
      worklet = new AudioWorkletNode(audioCtx, 'pcm-worklet');
      worklet.port.onmessage = (e)=>{
        txCount++;
        if(!$('#mute').checked && ws && ws.readyState===1){
          ws.send(e.data);
          workletSent++;
        }
      };
      source.connect(worklet);
      log(`âœ… Worklet å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
      setTimeout(()=>{
        if(workletSent===0){
          log("âš ï¸ Worklet ä¼¼ä¹æ²’æœ‰é€åŒ…ï¼Œåˆ‡æ› ScriptProcessor å¾Œå‚™è·¯ç·š");
          try{ worklet.disconnect(); }catch(_){}
          useScriptProcessor(source);
        }
      }, 600);
    }catch(e){
      log(`âš ï¸ Worklet å•Ÿç”¨å¤±æ•—ï¼š${e}`);
      const source = audioCtx.createMediaStreamSource(stream);
      useScriptProcessor(source);
    }

    // ä¸Šè¡Œé€Ÿç‡
    txTimer = setInterval(()=>{
      $('#tx').textContent = `TX: ${txCount} pkt/s`;
      txCount = 0;
    }, 1000);

    joined = true; $('#join').disabled=true; $('#leave').disabled=false;
    pingTimer = setInterval(()=>{ try{ ws.send(JSON.stringify({type:"ping"})); }catch(_){ } }, 20000);
  };

  ws.onmessage = (ev)=>{
    if(ev.data instanceof ArrayBuffer){
      // ç¬¬ä¸€å€‹ byte æ¨™ç¤ºé¡å‹ï¼š0x01=tts(mp3), 0x02=raw(wav)
      const u8 = new Uint8Array(ev.data);
      const kind = u8[0];
      const audioData = ev.data.slice(1);

      if(kind===0x01){ // TTS
        if(!$('#playTTS').checked) return;
        playAudio(audioData, 'audio/mpeg');
      }else if(kind===0x02){ // RAW
        if(!$('#wantRaw').checked) return;
        playAudio(audioData, 'audio/wav');
      }
      return;
    }
    // æ–‡å­—äº‹ä»¶
    try{
      const o=JSON.parse(ev.data);
      if(o.type==="join")   log(`ğŸ”µ ${o.name} åŠ å…¥ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="leave")  log(`âšª ${o.name} é›¢é–‹ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="mute")   log(`ğŸ”‡ ${o.name} ${o.muted?"å·²éœéŸ³":"å–æ¶ˆéœéŸ³"}`);
      if(o.type==="final")  log(`âœ… ${o.from}ï¼ˆ${o.dir} å®Œæ•´ï¼‰\nåŸæ–‡ï¼š${o.text}\nç¿»è­¯ï¼š${o.mt}`);
      if(o.type==="error")  log(`âŒ ${o.msg}`);
    }catch(_){}
  };

  ws.onclose = ()=>{
    log("é€£ç·šé—œé–‰");
    $('#status').textContent="æœªé€£ç·š"; $('#status').classList.remove('now');
    $('#join').disabled=false; $('#leave').disabled=true;
    cleanupAudio(); joined=false;
  };
}

function useScriptProcessor(source){
  const sp = audioCtx.createScriptProcessor(2048, 1, 1);
  sp.onaudioprocess = (e)=>{
    const ch = e.inputBuffer.getChannelData(0);
    const ratio = 3; // 48k -> 16k
    const outLen = Math.floor(ch.length/ratio);
    const pcm = new Int16Array(outLen);
    for(let i=0;i<outLen;i++){
      let s = ch[i*ratio];
      if(s>1) s=1; if(s<-1) s=-1;
      pcm[i] = s<0 ? s*0x8000 : s*0x7FFF;
    }
    const pkt=320;
    for(let off=0; off<pcm.length; off+=pkt){
      const sl=pcm.subarray(off, off+pkt);
      if(sl.length===pkt){
        txCount++;
        if(!$('#mute').checked && ws && ws.readyState===1){
          ws.send(sl.buffer);
        }
      }
    }
  };
  try{ source.connect(sp); /* sp ä¸æ¥åˆ° destination ä»¥å…å›æˆ */ }catch(_){}
  log(`âœ… ScriptProcessor å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
}

function cleanupAudio(){
  try{ worklet && worklet.disconnect(); }catch(_){}
  try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch(_){}
  try{ audioCtx && audioCtx.close(); }catch(_){}
  try{ clearInterval(txTimer); }catch(_){}
  try{ clearInterval(pingTimer); }catch(_){}
  worklet=null; audioCtx=null; stream=null; txTimer=null; pingTimer=null; txCount=0;
}

function leave(){
  if(ws){ try{ ws.close(); }catch(_){} }
  cleanupAudio();
  $('#join').disabled=false; $('#leave').disabled=true; joined=false;
}

function playAudio(buf, mime){
  const blob=new Blob([buf],{type:mime});
  const url=URL.createObjectURL(blob);
  const a=new Audio(url);
  a.onended=()=>URL.revokeObjectURL(url);
  a.play().catch(()=>{ /* æŸäº›ç€è¦½å™¨éœ€äº’å‹•æˆæ¬Š */ });
}

$('#join').onclick = join;
$('#leave').onclick = leave;
$('#mute').onchange     = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'mute', value:$('#mute').checked})); };
$('#playSelf').onchange = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'play_self', value:$('#playSelf').checked})); };
$('#playTTS').onchange  = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'play_tts',  value:$('#playTTS').checked})); };
$('#wantRaw').onchange  = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'want_raw',  value:$('#wantRaw').checked})); };
navigator.mediaDevices.addEventListener('devicechange', listMics);
listMics();
</script>
</body>
</html>
