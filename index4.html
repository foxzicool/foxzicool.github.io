<!doctype html>
<html lang="zh-Hant">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï½œåªæ’­è­¯éŸ³ï¼ˆæœ¬äººä¸å›æ”¾ï¼‰</title>
<style>
  body{font-family:system-ui,-apple-system,"Noto Sans TC","Microsoft JhengHei",Arial;padding:20px;max-width:920px;margin:auto}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  input,select,button{padding:8px 10px;border:1px solid #bbb;border-radius:10px;background:#fff}
  button{cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .pill{padding:4px 10px;border-radius:999px;background:#efefef;font-size:12px}
  .logs{margin-top:12px;padding:10px;border:1px solid #eee;border-radius:10px;background:#fafafa;height:380px;overflow:auto;font-size:14px;white-space:pre-wrap}
  .now{color:#1b7fbd}
  .stat{font-family:monospace}
  .hint{color:#666;font-size:13px}
</style>
<body>
  <h2>ä¸­â†”éŸ“ åŒè²å‚³è­¯ï¼ˆåªæ’­æ”¾ã€Œç¿»è­¯å¾Œçš„æ©Ÿå™¨èªéŸ³ã€ï¼›å¾ä¸æ’­æ”¾ä»»ä½•äººè²ï¼‰</h2>

  <div class="row">
    <label>åç¨±</label>
    <input id="name" type="text" value="Public" />
    <label>ä¾†æºèªè¨€</label>
    <select id="srcLang">
      <option value="zh" selected>ä¸­æ–‡</option>
      <option value="ko">éŸ“æ–‡</option>
    </select>
    <button id="join">åŠ å…¥</button>
    <button id="leave" disabled>é›¢é–‹</button>
    <span class="pill" id="status">æœªé€£ç·š</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label><input id="mute" type="checkbox"> ä¸é€å‡ºéº¥å…‹é¢¨</label>
    <label><input id="echo" type="checkbox" checked> å›è²æŠ‘åˆ¶</label>
    <label><input id="ns"   type="checkbox" checked> é™å™ª</label>
    <label><input id="agc"  type="checkbox"> è‡ªå‹•å¢ç›Š</label>
    <span class="stat" id="tx">TX: 0 pkt/s</span>
  </div>

  <div class="row" style="margin-top:10px">
    <label for="micSel">è¼¸å…¥è£ç½®</label>
    <select id="micSel"></select>
    <label for="outSel">è¼¸å‡ºè£ç½®ï¼ˆæ’­æ”¾åˆ¥äººçš„ã€Œè­¯éŸ³ MP3ã€ï¼‰</label>
    <select id="outSel"></select>
    <span class="hint">æœ¬é æ°¸é ä¸æœƒæ’­æ”¾äººè²ï¼›åªæœ‰ã€Œç¿»è­¯å¾Œçš„æ©Ÿå™¨èªéŸ³ã€æœƒæ’­æ”¾ï¼Œè€Œä¸”ç™¼è©±è€…æœ¬äººä¸æœƒè½åˆ°è‡ªå·±é‚£ä¸€å¥ã€‚</span>
  </div>

  <div class="logs" id="logs"></div>

<script>
let ws=null, audioCtx=null, sp=null, stream=null, pingTimer=null, txTimer=null;
let txPkts=0;

let devicesCache=[]; let currentMicId=""; let currentOutId="";

const $ = (s)=>document.querySelector(s);
const log = (s)=>{ const el=$('#logs'); el.textContent+=s+"\n"; el.scrollTop=el.scrollHeight; };

function requireHost(){
  const host = new URLSearchParams(location.search).get('host') || "";
  if(!host){
    log("âŒ è«‹åœ¨ç¶²å€å¾ŒåŠ ä¸Š ?host=<ä½ çš„ trycloudflare ä¸»æ©Ÿ> æ‰èƒ½é€£ç·šï¼Œä¾‹å¦‚ï¼š?host=performances-xxxx.trycloudflare.com");
    $('#join').disabled = true;
    return null;
  }
  return host.replace(/^https?:\/\//,'').replace(/\/+$/,'');
}

async function refreshDevices(){
  devicesCache = await navigator.mediaDevices.enumerateDevices();
  const mics = devicesCache.filter(d=>d.kind==="audioinput");
  const outs = devicesCache.filter(d=>d.kind==="audiooutput");
  const micSel=$('#micSel'); micSel.innerHTML="";
  mics.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label || `éº¥å…‹é¢¨(${d.deviceId.slice(0,6)}â€¦)`; micSel.appendChild(o); });
  const outSel=$('#outSel'); outSel.innerHTML="";
  outs.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label || `è¼¸å‡º(${d.deviceId.slice(0,6)}â€¦)`; outSel.appendChild(o); });
  if (currentMicId && [...micSel.options].some(o=>o.value===currentMicId)) micSel.value=currentMicId;
  if (currentOutId && [...outSel.options].some(o=>o.value===currentOutId)) outSel.value=currentOutId;
}

async function getMicStream(deviceId){
  const cts = {
    audio:{
      deviceId: deviceId ? {exact: deviceId} : undefined,
      channelCount:{ideal:1}, sampleRate:{ideal:48000}, sampleSize:{ideal:16},
      echoCancellation:{ideal: $('#echo').checked},
      noiseSuppression:{ideal: $('#ns').checked},
      autoGainControl:{ideal: $('#agc').checked}
    }
  };
  return await navigator.mediaDevices.getUserMedia(cts);
}

function cleanupAudio(){
  try{ sp && sp.disconnect(); }catch(_){}
  try{ stream && stream.getTracks().forEach(t=>t.stop()); }catch(_){}
  try{ audioCtx && audioCtx.close(); }catch(_){}
  try{ clearInterval(pingTimer); }catch(_){}
  try{ clearInterval(txTimer); }catch(_){}
  sp=null; audioCtx=null; stream=null; pingTimer=txTimer=null; txPkts=0;
}

function leave(){
  if(ws){ try{ ws.close(); }catch(_){ } }
  cleanupAudio();
  $('#join').disabled = false;
  $('#leave').disabled = true;
  $('#status').textContent="æœªé€£ç·š"; $('#status').classList.remove('now');
}

async function fallbackScriptProcessor(source){
  const zeroGain = audioCtx.createGain(); zeroGain.gain.value = 0;
  sp = audioCtx.createScriptProcessor(2048,1,1);
  sp.onaudioprocess = (ev)=>{
    const ch=ev.inputBuffer.getChannelData(0);
    const ratio=48000/16000;
    const outLen=Math.floor(ch.length/ratio);
    const pcm=new Int16Array(outLen);
    for(let i=0;i<outLen;i++){
      const idx=(i*ratio)|0; let s=ch[idx];
      if(s>1) s=1; if(s<-1) s=-1;
      pcm[i]=s<0?s*0x8000:s*0x7FFF;
    }
    const pkt=320;
    for(let off=0; off<pcm.length; off+=pkt){
      const sl=pcm.subarray(off, off+pkt);
      if(sl.length===pkt){
        txPkts++;
        if(!$('#mute').checked && ws && ws.readyState===1){
          ws.send(sl.buffer);
        }
      }
    }
  };
  // éŸ³é‡=0ï¼Œé¿å…ä»»ä½•æœ¬æ©Ÿå›æ”¾
  source.connect(sp); sp.connect(zeroGain); zeroGain.connect(audioCtx.destination);
  log(`âœ… ScriptProcessor å·²å•Ÿç”¨ï¼ˆctxRate=${audioCtx.sampleRate}Hzï¼‰`);
}

async function join(){
  const host = requireHost();
  if(!host) return;

  try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){}
  await refreshDevices();

  const name = ($('#name').value || 'Guest').trim().slice(0,40);
  const srcLang = $('#srcLang').value;

  const WS_URL = `wss://${host}/ws`;
  ws = new WebSocket(WS_URL);
  ws.binaryType = 'arraybuffer';

  ws.onopen = async ()=>{
    $('#status').textContent="å·²é€£ç·š"; $('#status').classList.add('now');
    ws.send(JSON.stringify({name, src_lang: srcLang}));

    try{
      const devId = $('#micSel').value || undefined;
      stream = await getMicStream(devId);
      const info = stream.getAudioTracks()[0]?.getSettings?.() || {};
      log(`ğŸ™ï¸ micï¼š${(stream.getAudioTracks()[0]?.label)||'æœªçŸ¥'} | è¨­å®šï¼š${JSON.stringify(info)}`);
    }catch(e){ log(`âŒ å–å¾—éº¥å…‹é¢¨å¤±æ•—ï¼š${e}`); return; }

    audioCtx = new (window.AudioContext||window.webkitAudioContext)({sampleRate:48000});
    await audioCtx.resume().catch(()=>{});
    const source = audioCtx.createMediaStreamSource(stream);
    await fallbackScriptProcessor(source);

    txTimer = setInterval(()=>{ $('#tx').textContent = `TX: ${txPkts} pkt/s`; txPkts=0; }, 1000);
    $('#join').disabled = true;
    $('#leave').disabled = false;
    pingTimer = setInterval(()=>{ try{ ws.send(JSON.stringify({type:"ping"})); }catch(_){ } }, 20000);
  };

  ws.onmessage = async (ev)=>{
    if(ev.data instanceof ArrayBuffer){
      // å¾Œç«¯åªå‚³ã€Œç¿»è­¯å¾Œçš„ MP3ã€ï¼Œä¸”ä¸æœƒå›é€çµ¦ç™¼è©±è€…æœ¬äºº
      const blob = new Blob([ev.data], {type:'audio/mpeg'});
      const url  = URL.createObjectURL(blob);
      const a = new Audio(url);
      a.autoplay = true;
      if (typeof a.setSinkId === 'function' && $('#outSel').value){
        try { await a.setSinkId($('#outSel').value); } catch(e){ log(`âš ï¸ è¨­å®šè¼¸å‡ºå¤±æ•—ï¼š${e}`); }
      }
      a.onended = ()=>{ URL.revokeObjectURL(url); };
      a.play().catch(()=>{});
      return;
    }
    try{
      const o=JSON.parse(ev.data);
      if(o.type==="join")  log(`ğŸ”µ ${o.name} åŠ å…¥ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="leave") log(`âšª ${o.name} é›¢é–‹ï¼Œäººæ•¸ ${o.count}`);
      if(o.type==="final") log(`âœ… ${o.from}ï¼ˆ${o.dir}ï¼‰\nåŸæ–‡ï¼š${o.text}\nç¿»è­¯ï¼š${o.mt}`);
      if(o.type==="mute")  log(`ğŸ”‡ ${o.name} ${o.muted?"å·²éœéŸ³":"å–æ¶ˆéœéŸ³"}`);
      if(o.type==="error") log(`âŒ ${o.msg}`);
      // ä¸è™•ç†ä»»ä½• tts_clientï¼ˆå‰ç«¯æ°¸ä¸åšæœ¬åœ° TTSï¼‰
    }catch(_){}
  };

  ws.onclose = ()=>{ log("é€£ç·šé—œé–‰"); leave(); };
}

$('#join').onclick = join;
$('#leave').onclick = leave;
$('#mute').onchange = ()=>{ if(ws && ws.readyState===1) ws.send(JSON.stringify({type:'mute', value:$('#mute').checked})); };
$('#micSel').onchange = async ()=>{ currentMicId = $('#micSel').value || ""; await refreshDevices(); };
$('#outSel').onchange = ()=>{ currentOutId = $('#outSel').value || ""; };
navigator.mediaDevices.addEventListener('devicechange', refreshDevices);
(async ()=>{ try{ await navigator.mediaDevices.getUserMedia({audio:true}); }catch(_){ } await refreshDevices(); })();
</script>
</body>
</html>
