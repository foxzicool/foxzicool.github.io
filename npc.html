<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Plain 3200×3200 | NPC x4 | Obstacles | Arrow</title>
  <style>
    body { margin:0; background:#111; display:grid; place-items:center; height:100vh; }
    #game { box-shadow:0 8px 24px rgba(0,0,0,.4); }
    .hud { position:fixed; left:12px; top:12px; color:#fff; font:14px system-ui,Segoe UI,Arial;
           background:rgba(0,0,0,.55); padding:8px 10px; border-radius:8px; user-select:none; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
</head>
<body>
<div id="game"></div>
<div class="hud">
  <div>方向鍵 / WASD 移動、E 對話</div>
  <div id="sizeLabel"></div>
</div>

<script>
class MainScene extends Phaser.Scene {
  constructor(){ super('main'); }

  preload() {
    // 草地 32x32 紋理
    const grass = this.textures.createCanvas('grass', 32, 32);
    const g = grass.getContext();
    g.fillStyle = '#3aa64a'; g.fillRect(0,0,32,32);
    for (let i=0;i<160;i++){ const x=(Math.random()*32)|0,y=(Math.random()*32)|0;
      g.fillStyle = `rgba(0,0,0,${0.07+Math.random()*0.12})`; g.fillRect(x,y,1,1);
    }
    g.fillStyle = 'rgba(255,255,255,0.05)'; g.fillRect(2,2,5,1); g.fillRect(12,5,6,1);
    grass.refresh();

    // 箭頭（朝右）
    const arrow = this.textures.createCanvas('arrow', 36, 36);
    const a = arrow.getContext();
    a.clearRect(0,0,36,36); a.fillStyle='#ffe066'; a.strokeStyle='#000'; a.lineWidth=2;
    a.beginPath(); a.moveTo(28,18); a.lineTo(10,8); a.lineTo(10,28); a.closePath(); a.fill(); a.stroke();
    arrow.refresh();

    // 陰影紋理（通用）— 半透明黑色橢圓
    const sh = this.textures.createCanvas('shadow', 40, 24);
    const shc = sh.getContext();
    shc.clearRect(0,0,40,24); shc.fillStyle='rgba(0,0,0,0.35)';
    shc.beginPath(); shc.ellipse(20, 14, 16, 8, 0, 0, Math.PI*2); shc.fill();
    sh.refresh();

    // 嘗試載入外部圖（讀不到就用程式備援）
    this.load.image('player', 'assets/player.png');
    this.load.image('npc',    'assets/npc.png');
    this.load.image('tree',   'assets/tree.png');
    this.load.image('rock',   'assets/rock.png');

    this.load.on('complete', () => {
      const ensure = (key, paint)=>{ if(!this.textures.exists(key)){ const t=this.textures.createCanvas(key,32,32); paint(t.getContext()); t.refresh(); } };
      ensure('player', ctx=>{ ctx.clearRect(0,0,32,32); ctx.fillStyle='#1e90ff'; ctx.beginPath(); ctx.arc(16,16,12,0,Math.PI*2); ctx.fill(); });
      ensure('npc',    ctx=>{ ctx.clearRect(0,0,32,32); ctx.fillStyle='#ffb347'; ctx.beginPath(); ctx.arc(16,16,12,0,Math.PI*2); ctx.fill(); });
      ensure('tree',   ctx=>{ ctx.clearRect(0,0,32,32); ctx.fillStyle='#2e7d32'; ctx.beginPath(); ctx.arc(16,14,12,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#8d6e63'; ctx.fillRect(14,18,4,10); });
      // rock：較寫實一點的亮暗層
      ensure('rock',   ctx=>{
        ctx.clearRect(0,0,32,32);
        ctx.fillStyle='#8a8a8a'; ctx.beginPath(); ctx.ellipse(16,18,13,9,0,0,Math.PI*2); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.25)'; ctx.beginPath(); ctx.ellipse(12,14,6,4,0,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.3)'; ctx.lineWidth=1; ctx.beginPath(); ctx.ellipse(16,18,13,9,0,0,Math.PI*2); ctx.stroke();
      });
    });
  }

  create() {
    // === 固定地圖 3200×3200（100×100 tiles × 32） ===
    const tileW=32,tileH=32, tilesX=100, tilesY=100;
    this.map = this.make.tilemap({ tileWidth: tileW, tileHeight: tileH, width: tilesX, height: tilesY });
    const tileset = this.map.addTilesetImage('grass','grass',tileW,tileH,0,0,1);
    this.ground = this.map.createBlankLayer('ground', tileset, 0, 0);
    this.ground.fill(1);

    // 物理邊界 & 相機
    this.physics.world.setBounds(0,0,this.map.widthInPixels,this.map.heightInPixels);
    this.cameras.main.setBounds(0,0,this.map.widthInPixels,this.map.heightInPixels);
    this.cameras.main.setRoundPixels(true);

    // 玩家
    const pTex = this.textures.get('player').getSourceImage();
    const pScale = 32 / pTex.width;
    const startX = this.map.widthInPixels/2, startY = this.map.heightInPixels/2;
    this.player = this.physics.add.image(startX,startY,'player').setScale(pScale).setDepth(5);
    this.player.setCollideWorldBounds(true);
    this.player.body.setSize(this.player.displayWidth*0.6, this.player.displayHeight*0.8, true);

    // 相機跟隨
    this.cameras.main.startFollow(this.player, true, 0.2, 0.2);

    // 群組（靜態剛體）
    this.npcs  = this.physics.add.staticGroup();
    this.trees = this.physics.add.staticGroup();
    this.rocks = this.physics.add.staticGroup();

    // NPC = 4 位
    this.spawnNPCs(4);

    // 樹 & 石（不可穿越）：數量「一般般」，會依面積取個適中值
    this.scatterDecor();

    // 碰撞
    this.physics.add.collider(this.player, this.trees);
    this.physics.add.collider(this.player, this.rocks);
    this.physics.add.collider(this.player, this.npcs);

    // 箭頭（指向最近 NPC）
    this.arrow = this.add.image(0,0,'arrow').setOrigin(0.5).setDepth(20).setScale(0.9);

    // 陰影 Graphics（每禎重畫，可視區只有幾百個物件也沒問題）
    this.shadowGfx = this.add.graphics().setDepth(4);

    // 對話 UI（固定螢幕左下）
    this.interactRadius = 42;
    this.interactHint = this.add.text(0,0,'按 E 對話',{fontSize:'16px',color:'#fff',backgroundColor:'#0008',padding:{x:8,y:4}}).setDepth(30).setVisible(false);
    this.dialogBox  = this.add.rectangle(260, this.game.config.height-60, 420, 90, 0x000000, 0.75).setStrokeStyle(2,0xffffff).setDepth(30).setScrollFactor(0).setVisible(false);
    this.dialogText = this.add.text(70, this.game.config.height-95, '', {fontSize:'18px', color:'#fff', wordWrap:{width:400}}).setDepth(31).setScrollFactor(0).setVisible(false);

    // 鍵盤
    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys = this.input.keyboard.addKeys('W,A,S,D,E');
    this.speed = 240;

    // HUD
    document.getElementById('sizeLabel').textContent =
      `地圖：3200×3200　NPC：${this.npcs.getLength()}　樹：${this.trees.getLength()}　石：${this.rocks.getLength()}`;
  }

  randomPos(margin=64){
    const x = Phaser.Math.Between(margin, this.map.widthInPixels - margin);
    const y = Phaser.Math.Between(margin, this.map.heightInPixels - margin);
    return { x, y };
  }

  spawnNPCs(count){
    this.npcs.clear(true,true);
    const nTex = this.textures.get('npc').getSourceImage();
    const nScale = 32 / nTex.width;
    for (let i=0;i<count;i++){
      const p = this.randomPos(96);
      const npc = this.npcs.create(p.x,p.y,'npc').setScale(nScale).setDepth(5);
      npc.refreshBody();
      npc.data = { name:`村民 #${i+1}` };
    }
  }

  scatterDecor(){
    this.trees.clear(true,true); this.rocks.clear(true,true);
    // 100×100 tiles → 面積 10000，取「一般般」密度
    const treeCount = 55;     // 你可調整
    const rockCount = 45;     // 放大也更顯眼
    const tTex = this.textures.get('tree').getSourceImage();
    const rTex = this.textures.get('rock').getSourceImage();

    // 樹固定約 32 像素，石頭放大到 ~48 像素、帶些隨機旋轉/縮放（寫實感）
    const tBaseScale = 32 / tTex.width;
    const rTargetPx  = 48; const rBaseScale = rTargetPx / rTex.width;

    const minDistFromPlayer = 160;
    const minDistFromNPC = 70;
    const npcPos = () => this.npcs.getChildren().map(n => new Phaser.Math.Vector2(n.x,n.y));
    const tooClose = (x,y, pts, d) => pts.some(p => Phaser.Math.Distance.Between(x,y,p.x,p.y) < d);

    // 樹
    for (let i=0, placed=0; placed<treeCount && i<treeCount*20; i++){
      const p = this.randomPos(64);
      if (Phaser.Math.Distance.Between(p.x,p.y, this.map.widthInPixels/2, this.map.heightInPixels/2) < minDistFromPlayer) continue;
      if (tooClose(p.x,p.y, npcPos(), minDistFromNPC)) continue;
      const t = this.trees.create(p.x,p.y,'tree').setScale(tBaseScale).setDepth(5);
      t.refreshBody(); placed++;
    }

    // 石（放大 + 隨機旋轉/縮放）
    for (let i=0, placed=0; placed<rockCount && i<rockCount*25; i++){
      const p = this.randomPos(64);
      if (Phaser.Math.Distance.Between(p.x,p.y, this.map.widthInPixels/2, this.map.heightInPixels/2) < minDistFromPlayer) continue;
      if (tooClose(p.x,p.y, npcPos(), minDistFromNPC)) continue;
      const s = rBaseScale * Phaser.Math.FloatBetween(0.9, 1.2);
      const r = this.rocks.create(p.x,p.y,'rock').setScale(s).setDepth(5);
      r.setRotation(Phaser.Math.FloatBetween(-0.35, 0.35));
      r.refreshBody(); placed++;
    }
  }

  drawShadows(){
    // 在可視區塊內為 玩家 / NPC / 樹 / 石頭 畫半透明陰影
    const gfx = this.shadowGfx;
    gfx.clear();
    gfx.fillStyle(0x000000, 0.28);
    const cam = this.cameras.main;
    const drawEllipse = (x,y,w,h) => {
      // 只畫在鏡頭附近，省一點點功
      if (x < cam.worldView.x-80 || x > cam.worldView.right+80 || y < cam.worldView.y-80 || y > cam.worldView.bottom+80) return;
      gfx.fillEllipse(x, y+10, w, h);
    };

    // 玩家
    drawEllipse(this.player.x, this.player.y, 26, 14);
    // NPC
    this.npcs.getChildren().forEach(n => drawEllipse(n.x, n.y, 26, 14));
    // 樹（大一點）
    this.trees.getChildren().forEach(t => drawEllipse(t.x, t.y, 30, 16));
    // 石（依縮放略調）
    this.rocks.getChildren().forEach(r => drawEllipse(r.x, r.y, 28 * r.scaleX, 14 * r.scaleY));
  }

  update() {
    // 移動
    const v = 240;
    this.player.body.setVelocity(0);
    if (this.cursors.left.isDown || this.keys.A.isDown)  this.player.body.setVelocityX(-v);
    if (this.cursors.right.isDown|| this.keys.D.isDown)  this.player.body.setVelocityX(v);
    if (this.cursors.up.isDown   || this.keys.W.isDown)  this.player.body.setVelocityY(-v);
    if (this.cursors.down.isDown || this.keys.S.isDown)  this.player.body.setVelocityY(v);

    // 最近 NPC + 箭頭
    const list = this.npcs.getChildren();
    let nearest=null, minD=1e9;
    for(const n of list){ const d=Phaser.Math.Distance.Between(this.player.x,this.player.y,n.x,n.y); if(d<minD){minD=d; nearest=n;} }
    if (nearest && minD > this.interactRadius + 6){
      this.arrow.setVisible(true).setPosition(this.player.x, this.player.y - 34);
      this.arrow.setRotation(Phaser.Math.Angle.Between(this.player.x, this.player.y, nearest.x, nearest.y));
    } else {
      this.arrow.setVisible(false);
    }

    // 對話
    if (nearest && minD < this.interactRadius){
      this.interactHint?.setVisible(true).setPosition(this.player.x - 30, this.player.y - 50);
      if (Phaser.Input.Keyboard.JustDown(this.keys.E)){
        const show = !this.dialogBox.visible;
        this.dialogBox.setVisible(show);
        this.dialogText.setText(`${nearest.data?.name || 'NPC'}：哈囉，勇者！這是示範對話。\n（再按 E 關閉/開啟）`).setVisible(show);
      }
    } else {
      this.interactHint?.setVisible(false);
      if (this.dialogBox.visible){ this.dialogBox.setVisible(false); this.dialogText.setVisible(false); }
    }

    // 陰影重畫
    this.drawShadows();
  }
}

new Phaser.Game({
  type: Phaser.AUTO,
  parent: 'game',
  width: 960,
  height: 600,
  backgroundColor: '#222',
  pixelArt: true,
  physics: { default:'arcade', arcade:{ gravity:{y:0}, debug:false } },
  scene: [MainScene]
});
</script>
</body>
</html>
